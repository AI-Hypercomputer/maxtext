# Copyright 2023 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Config file for a test job.

Note on dataclasses:

Why not use data classes? Before Python 3.10, init parameters for inherited
data classes are put in the order in which they are defined. Take this example:

```
class TestConfig(abc.ABC, Generic[A]):
  accelerator: A
  task_owner: Optional[str] = None

class TpuVmTest(TestConfig[Tpu]):
  test_name: str
```

`TpuVmTest.__init__`'s signature will be something like this:

```
def __init__(self, accelerator, task_owner=None, test_name):
  ...
```

Putting required positional arguments after required ones is, of course, not
allowed. This prevents us from defining any optional parameters on the parent
class. Python 3.10 adds keyword-only dataclass fields, but we have to get that
functionality from `attrs` for now.

When Composer updates to a recent Python version, we can use dataclasses.
"""

import abc
from typing import Generic, Iterable, Optional, TypeVar
import attrs


class Accelerator(abc.ABC):
  """Represents an ML accelerator."""

  @property
  @abc.abstractmethod
  def name(self) -> str:
    """Name of this ML accelerator."""
    raise NotImplementedError


# TODO(wcromar): GPU implementation
@attrs.define
class Tpu(Accelerator):
  """Represents a single Cloud TPU instance.

  Attributes:
    version: TPU device version.
    cores: Physical cores in this TPU type, i.e. the number of cores in the
      name.
    runtime_version: Runtime image version.
    network: The network that a TPU will be a part of.
    subnetwork: The subnetwork that a TPU will be a part of.
    reserved: The flag to define if a TPU is a Cloud reservation.
  """

  version: str
  cores: int
  runtime_version: str
  network: str = 'default'
  subnetwork: str = 'default'
  reserved: bool = False

  @property
  def name(self):
    """Name of this TPU type in the Cloud TPU API (e.g. 'v4-8')."""
    return f'v{self.version}-{self.cores}'


A = TypeVar('A', bound=Accelerator)


@attrs.define
class TestConfig(abc.ABC, Generic[A]):
  """Base class for end-to-end test configurations.

  Attributes:
    accelerator: Accelerator type required for this test.
    time_out_in_min: Test timeout in minutes.
    task_owner: Task owner username or link.
  """

  accelerator: A
  time_out_in_min: Optional[int] = attrs.field(default=None, kw_only=True)
  task_owner: Optional[str] = attrs.field(default=None, kw_only=True)

  @property
  @abc.abstractmethod
  def benchmark_id(self) -> str:
    """Unique key for metrics generated by this test."""
    ...

  @property
  def setup_script(self) -> Optional[str]:
    """Optional script to run once when the accelerator is created."""
    return None

  @property
  @abc.abstractmethod
  def test_script(self) -> str:
    """Script to run on accelerator machine.

    The exit code of this script will be the test result.
    """
    ...


@attrs.define
class TpuVmTest(TestConfig[Tpu]):
  """Test config that runs on a single Cloud TPU VM instance.

  Attributes:
    test_name: Unique name for this test/model.
    set_up_cmds: List of commands to run once when TPU is created.
    run_model_cmds: List of commands to run the model under test.
  """

  test_name: str
  set_up_cmds: Iterable[str]
  run_model_cmds: Iterable[str]

  @property
  def benchmark_id(self) -> str:
    return f'{self.test_name}-{self.accelerator.name}'

  @property
  def setup_script(self) -> Optional[str]:
    return '\n'.join(self.set_up_cmds)

  @property
  def test_script(self) -> str:
    return '\n'.join(self.run_model_cmds)
